---
layout: post
title: 'Recipe: RESTful permissions for Rails'
date: 2008-08-24 13:59:23.000000000 -07:00
categories:
- Ruby/Rails
tags:
- broadcast
status: publish
type: post
published: true
meta:
  _edit_last: '1'
author:
  login: jhund
  email: jhund@clearcove.ca
  display_name: jhund
  first_name: ''
  last_name: ''
excerpt: !ruby/object:Hpricot::Doc
  options: {}
---
<p>A common requirement for Rails applications is to check permissions for certain actions on your RESTful application's resources. There are many ways to solve this problem, ranging from simple boolean flags to full fledged <a href="http://www.railsforum.com/viewtopic.php?id=14216">role based access control</a>. I have tried a lot of approaches and have settled on a fairly simple way that is RESTful and quite flexible.</p>
<p><!--more--></p>
<h2>Updates</h2>
<ul>
<li>20081023 - see the code for this and other recipes at <a href="http://github.com/jhund/rails-recipes/tree/master">github</a></li>
<li>20081018 - changed syntax highlighter, replaced Person with User</li>
</ul>
<h2>Scope</h2>
<p>What it does and what it does not: We are just controlling access to our app's resources at the view and controller level, i.e. access through the web. We do not check permissions on a model or file level. That means anybody with access to the server can mess with your files, database, and models.</p>
<p>I consider this approach the sweet spot for most of my applications which don't contain super sensitive information.</p>
<h2>Overview</h2>
<p>There are a number of places where one needs to check for permissions in a rails app:</p>
<ul>
<li>in the <strong>View</strong> when deciding which controls a user should see: Should we display the edit button on that resource? Is this user allowed to delete this record? This approach renders UI elements only for those actions the current user has permission for.</li>
<li>in the <strong>Controller</strong> when protecting certain URLs. Even if you don't provide a link to access a resource in the view, it would be easy to guess the RESTful URL for certain operations. So every controller action checks permissions for the current user before any data is modified.</li>
<li>if you want it really secure, you also have to protect your <strong>Model</strong>. I might write about this later. It is beyond the scope of this article. Quick pointer: you could use ActiveRecord callbacks and raise exceptions if <code>current_user</code> does not have permissions.</li>
</ul>
<p>One issue that comes up when checking permissions is "How do models get access to <code>current_user</code>?". This is important for auditing and model security. I copied what Rails is doing: store the current user in <code>Thread.current[:user]</code> at the beginning of each request and wrap User.current around that variable. Then User.current is available everywhere in your app, not only in controllers and views.</p>
<h2>Recipe</h2>
<p>The following is the recipe for implementing RESTful permissions in an <em>Online Syllabus Builder</em> Rails app:</p>
<h3>User Model</h3>
<p>There isn't much you need on the user model. I assume you are using <a href="http://github.com/technoweenie/restful-authentication">restful_authentication</a> to handle users, signups, and logins. All I usually do these days is to add a boolean field for each role a user can have.</p>
<p>In our example the roles are 'is_admin' and 'is_editor'. For each role a user holds, the corresponding field is set to 'true'. You can then ask the user: current_user.is_admin? when checking for permissions.</p>
<h3>Resource Model</h3>
<p>Tell your model that it has permissions and customize any special permissions:</p>
<p>In <code>app/models/syllabus.rb</code></p>
<p>[code='ruby']<br />
class Syllabus < ActiveRecord::Base</p>
<p>  has_restful_permissions</p>
<p>  ...</p>
<p>  def updatable_by?(actor)<br />
    actor.is_a?(User) && (actor.is_admin? || self.owned_by?(actor))<br />
  end</p>
<p>  def owned_by?(actor)<br />
    actor == self.author<br />
  end</p>
<p>end<br />
[/code]</p>
<p>The statement <code>has_restful_permissions</code> includes the standard set of permissions (see bottom of this post for an example). You will find that in a RESTful app, most resources have the same rules for permissions, so you can extract the permission rules into a module and include it into your resources. Then you can override individual rules for resources that are different.</p>
<p>The method <code>updatable_by?</code> overrides the default permissions for the update action on Syllabus. In this case it grants permission to update a Syllabus to logged in users (<code>actor.is_a?(User)</code>) who are either admins (<code>actor.is_admin?</code>) or who own this syllabus (<code>self.owned_by?(actor)</code>).</p>
<p>The method <code>owned_by?</code> defines who owns this resource. This is the method you will have to override most often as there is no general solution that fits all. In this case we consider the author of a syllabus its owner. For nested resources, you can call <code>owned_by?</code> on the parent resource. Example:</p>
<p>In <code>app/models/text_block.rb</code></p>
<p>[code='ruby']<br />
class TextBlock < ActiveRecord::Base</p>
<p>  has_restful_permissions<br />
  belongs_to :syllabus</p>
<p>  def owned_by?(actor)<br />
    self.syllabus.owned_by?(actor)<br />
  end</p>
<p>end<br />
[/code]</p>
<h3>View</h3>
<p>Whenever you have a resource action link that is rendered based on the current user's permissions:</p>
<p>In <code>app/views/syllabi/index.html.erb<br />
</code></p>
<p>[code='ruby']<br />
<%= link_to('Edit', edit_syllabus_path(@syllabus)) if @syllabus.updatable_by?(current_user) %><br />
[/code]</p>
<p>The 'Edit' link is rendered only if the current_user has permission to update this syllabus.</p>
<p>There is a slight edge case when rendering links for creating a new resource. Because you don't have the resource instantiated when the view is rendered, you might have to call creatable_by? on the resource class instead of an instance. So <code>Syllabus.creatable_by?</code> instead of <code>@syllabus.creatable_by?</code></p>
<h3>Controller</h3>
<p>The remaining place to check permissions is in your controller actions. I usually instantiate the resource first and then check permissions so that I can consider ownership associations as well as any other permissions that depend on the state of the resource:</p>
<p>In <code>app/controllers/syllabi_controller.rb<br />
</code></p>
<p>[code='ruby']<br />
class SyllabiController < ApplicationController</p>
<p>  def index<br />
    # Note that this is the only case where we check permissions on the class<br />
    raise PermissionViolation unless Syllabus.listable_by?(current_user)<br />
    @syllabi = ...<br />
    ...<br />
  end</p>
<p>  def show<br />
    @syllabus = Syllabus.find(params[:id])<br />
    raise PermissionViolation unless @syllabus.updatable_by?(current_user)<br />
    ...<br />
  end</p>
<p>  def new<br />
    @syllabus = Syllabus.new<br />
    raise PermissionViolation unless @syllabus.creatable_by?(current_user)<br />
    ...<br />
  end</p>
<p>  def edit<br />
    @syllabus = Syllabus.find(params[:id])<br />
    raise PermissionViolation unless @syllabus.updatable_by?(current_user)<br />
    ...<br />
  end</p>
<p>  def create<br />
    @syllabus = Syllabus.new(params[:syllabus])<br />
    raise PermissionViolation unless @syllabus.creatable_by?(current_user)<br />
    ...<br />
  end</p>
<p>  def update<br />
    @syllabus = Syllabus.find(params[:id])<br />
    raise PermissionViolation unless @syllabus.updatable_by?(current_user)<br />
    ...<br />
  end</p>
<p>  def destroy<br />
    @syllabus = Syllabus.find(params[:id])<br />
    raise PermissionViolation unless @syllabus.destroyable_by?(current_user)<br />
    ...<br />
  end<br />
end<br />
[/code]</p>
<p>I first instantiate the current resource and then I ask it whether the current_user has permission to perform the requested action. This assumes that instantiating the resource has no side effects.</p>
<p>You can handle a <code>PermissionViolation</code> in the application controller.</p>
<p>In <code>app/controllers/application.rb</code></p>
<p>[code='ruby']<br />
class ApplicationController < ActionController::Base</p>
<p>  def rescue_action(exception)<br />
    case exception<br />
      when PermissionViolation<br />
        flash[:warning] = "You do not have permission for this action."<br />
        redirect_to :back<br />
      else<br />
        super<br />
    end<br />
  end</p>
<p>end<br />
[/code]</p>
<h3>Permission types</h3>
<p>This list contains the most common permissions for a RESTful resource. You might need additional permissions for each custom action method you add in <code>routes.rb</code> to member or collection:</p>
<ul>
<li>show: <code>@syllabus.viewable_by?(current_user)</code></li>
<li>edit and update: <code>@syllabus.updatable_by?(current_user)</code></li>
<li>new and create: <code>@syllabus.creatable_by?(current_user)</code> — your initial instinct might be to make this a class method, however I found it useful to instantiate the new object, then check permissions before I actually save it. Allows you to consider associated resources for permission checks. Sometimes you need to call creatable_by? on the class. For example when rendering a 'new' link in a view that allows you to create a new resource, however you don't have one instantiated at that point to check permissions on.</li>
<li>destroy: <code>@syllabus.destroyable_by?(current_user)</code></li>
<li>index: <code>Syllabus.listable_by?(current_user)</code> — for list I use a class method because there is no single resource for lists.</li>
</ul>
<p>So what do these methods look like? Below are some example methods that you would define in your resource class:</p>
<p>Anybody can list syllabi:</p>
<p>[code='ruby']<br />
def self.listable_by?(actor)<br />
  true<br />
end<br />
[/code]</p>
<p>Logged in users can view this syllabus:<br />
[code='ruby']<br />
def viewable_by?(actor)<br />
  actor.is_a?(User)<br />
end<br />
[/code]</p>
<p>Admins and owners can update this post:<br />
[code='ruby']<br />
def updatable_by?(actor)<br />
  actor.is_a?(User) && (actor.is_admin? || self.owned_by?(actor))<br />
end<br />
[/code]</p>
<p>Nobody can destroy this post:<br />
[code='ruby']<br />
def destroyable_by?(actor)<br />
  false<br />
end<br />
[/code]</p>
<h2>Other implementations</h2>
<h3>Nick Kallen's post</h3>
<p>I found an <a href="http://pivots.pivotallabs.com/users/nick/blog/articles/272-access-control-permissions-in-rails">article by Nick Kallen</a> that proposed a very similar approach a while ago.</p>
<p>He uses active voice: <code>current_user.can_create(@syllabus)</code>. That works if you have an AnonymousUser object. And you also need to do the double dispatch where the user object then asks the resource whether it has permission. I find using the passive voice directly more concise &mdash; even though in general I prefer active voice. It is much less ambiguous.</p>
<p>One aspect Nick does not mention is the concept of resource ownership, handled by "<code>owned_by?(actor)</code>" in this example.</p>
<p>Also <a href="http://hobocentral.net/">Hobo</a> and <a href="http://github.com/spot-us/spot-us/tree/master">spot.us</a>, written by Hashrocket use a similar approach.</p>
<h3>make_resourceful</h3>
<p>This recipe integrates very nicely with the <a href="http://mr.hamptoncatlin.com/">make_resourceful</a> plugin. All you need to do is call</p>
<p>[code='ruby']<br />
raise PermissionViolation unless current_object.viewable_by?(current_user)<br />
[/code]</p>
<p>in the before_show callback. And then the resources take care of answering that question. I actually modified the plugin and added permissions checks in <code>/vendor/plugins/make_resourceful/lib/resourceful/default/actions.rb</code>:</p>
<p>[code='ruby']<br />
module Actions<br />
  # GET /foos<br />
  def index<br />
    #load_objects<br />
    raise PermissionViolation unless current_model.listable_by?(User.current)<br />
    before :index<br />
    response_for :index<br />
  end<br />
  ...<br />
end<br />
[/code]</p>
<h3>Confused deputy problem</h3>
<p>Something to keep in mind when working with permissions is what is called the "<a href="http://en.wikipedia.org/wiki/Confused_deputy_problem">confused deputy problem</a>". Where the app intends to give a particular permission to an actor. The actor then does something either inadvertently or on purpose that goes beyond the permission granted. This usually applies to file system resources and file permissions. However it can also happen in Rails through model associations. A user might have permission to delete resource A. Resource A <code>has_many :bs, dependent => :destroy</code>. When the user deletes resource A, Rails automatically also deletes resource B &mdash; which the user might not have permission for. You would need model based permissions to prevent this from happening.</p>
<h2>Code for default permissions</h2>
<p>Here is the code I usually include in resources that have permissions with "<code>has_restful_permissions</code>" in the class definition.</p>
<p>Require it with</p>
<pre> require 'has_restful_permissions'</pre>
<p>In <code>lib/has_restful_permissions.rb</code></p>
<p>[code='ruby']<br />
class PermissionViolation < StandardError; end</p>
<p>module HasRestfulPermissions</p>
<p>  # call this in resource class<br />
  def has_restful_permissions<br />
    extend  ClassMethods<br />
    include InstanceMethods<br />
  end</p>
<p>  module InstanceMethods</p>
<p>    # permission rules, override these in the resource class</p>
<p>    # Returns true if actor can create this new instance.<br />
    # I prefer the instance method over the class method<br />
    # because sometimes you need to look at the state<br />
    # of the newly instantiated object or its related objects<br />
    # to decide whether the current user is permitted to create it.<br />
    def creatable_by?(actor)<br />
      actor.is_a?(User)<br />
    end</p>
<p>    # Returns true if actor can destroy this resource.<br />
    def destroyable_by?(actor)<br />
      actor.is_a?(User) && self.owned_by?(actor)<br />
    end</p>
<p>    # Returns true if actor can update this resource.<br />
    def updatable_by?(actor)<br />
      actor.is_a?(User) && self.owned_by?(actor)<br />
    end</p>
<p>    # Returns true if actor can view this resource.<br />
    def viewable_by?(actor)<br />
      actor.is_a?(User)<br />
    end</p>
<p>    # Returns true if actor owns this resource.<br />
    # Expresses a control/ownership association.<br />
    # Expects actor to be a User (usually checked for in other<br />
    # permission methods before this method is called)<br />
    def owned_by?(actor)<br />
      # defaults to false. Override if resource has owner<br />
      false<br />
    end</p>
<p>  end</p>
<p>  module ClassMethods<br />
    # Returns true if actor can view a list of resources of this class.<br />
    def listable_by?(actor)<br />
      actor.is_a?(User)<br />
    end</p>
<p>    # alternative way to check if resource is creatable by actor.<br />
    # use this class method instead of the instance method if resource<br />
    # is not instantiated at time of checking permissions<br />
    # This is useful when deciding whether to render a "new" link<br />
    # used for creating a new resource.<br />
    def creatable_by?(actor)<br />
      actor.is_a?(User)<br />
    end<br />
  end</p>
<p>end</p>
<p>ActiveRecord::Base.send :extend, HasRestfulPermissions<br />
[/code]</p>
